# Standard_Week3
 
## 숙련 1~3강 

### 구현 내용 Player 입력부분 구현 

### 분석 문제:
#### 1.입문 주차와 비교해서 입력받는 방식의 차이와 공통점을 비교해보세요.

##### 입문 주차 때의 인풋 시스템 방식(Send Massages)은 설정한 Action의 이름에 따라 그 함수를 실행시키는 메서드 (Action의 이름 앞에 On이 붙은) 가 있는지 확인하여 실행시키는 방식이었다면 
Invoke Unity Events 방식은 유니티에서 제공하는 이벤트를 활용하여 작동시키는 방식으로 버튼을 등록하는 것 처럼 Action 이름에 해당하는 메서드를 끌어와 등록시킬 수 있습니다. 


#### 2.CharacterManager와 Player의 역할에 대해 고민해보세요

##### CharacterManager의 역할은 전역적으로 Player의 데이터에 접근할 수 있도록 하고 
Player은 오브젝트에 연결된 스크립트를 가져와 사용합니다. 이에 따라 Player 오브젝트의 정보를 전역적으로 사용할 수 있게 되면서 1~3강 뒤에 추가될 UI나 다른 오브젝트와의 상호작용을 돕습니다.

#### 3.핵심 로직을 분석해보세요 ( Move,CameraLook,IsGrounded)

##### Move는 플레이어의 이동을 담당하는 인풋입니다. 입력하는 vector2 값을 불러와 Player의 
Rigidbody를 제어합니다. vector2값은 x,y 값만을 사용하고 vector3에 적용시키기 위해선
먼저 vector3에서 xyz의 방향을 알아야했습니다.  2D 에서 위아래 와 왼쪽오른쪽만 구분하였다면
3D에선 앞 뒤도 구분하여야하고 이에 대응하여 X값은 그대로 유지하되 Vector3의 z값에 vector2의 y값을 집어넣어야 합니다.  또한 Rigidbody에 대입하는 vector3값의 y값을 Rigidbody 기존의 값을 넣은 이유는 
0으로 설정하면 나중에 AddForce를 사용할 때도 그 값이 고정되기 때문입니다.

##### Look은 플레이어의 시야를 담당하는 인풋입니다. 지속적인 값을 불러와야하기에 Action을 입력받는 형식을 PassThrough로 하였고 변화되는 마우스 커서의 vector2값을 불러와 사용합니다.  시야를 구현하려면 
카메라의 Rotation을 바꾸어야하는데 Rotation은 해당하는 방향의 축을 돌리는 것과 같기에 왼쪽 오른쪽 방향으로 돌리고 싶으면 y축을 건드리고 위 아래를 건드리고 싶으면 x축을 건드려야 하였습니다. 오른쪽 왼쪽으로 돌리는 것을 구현 할때 mathf.clamp를 써주어 돌리는데 최소값 최대값을 부여합니다.
또한 위 아래로 움직일 때 커서을 방향처럼 움직이려면 값을 반대로(-) 넣어주어야하는데 이유는 단순히 커서가 위로가면 y값은 +가되지만 Rotation 상에서 위로 올릴땐 - 가 되어야하기 때문입니다.

##### IsGrounded는 Ray를 발사하여 아래에 땅이 있을 때 점프가 되도록 조건을 걸기위해 bool값을 반환하는 메서드입니다.  Ray를 오브젝트보다 살짝 위와 앞으로 설정해주고 방향은 아래로 향하게 하여 Ground 레이어를
사용하고 있는 오브젝트와 Ray가 접촉하였는지 확인합니다.  만약 닿아있다면 true를 반환하여 조건에 성립하게 되고 아니라면 false를 반환하여 점프가 안되게 됩니다.

#### 4.Move와 CameraLook 함수를 각각 FixedUpdate, LateUpdate 에서 호출하는 이유를 생각해보세요.

##### FixedUpdate에 물리법칙을 집어넣어야 정상적적으로 물리법칙이 적용되기 때문입니다.  (FixedUpdate는 프레임 생명주기와 따로 동작함)

##### LateUpdate에 카메라의 동작을 넣는 이유는 다른 모든 동작을 마치고나서 카메라 조작이 수행되어야 자연스러워 보이기 때문입니다.
